defmodule Epicenter.Test.SchemaAssertions do
  import ExUnit.Assertions

  alias Epicenter.Test.SchemaAssertions.Database
  alias Epicenter.Test.SchemaAssertions.Schema

  @doc """
  Assert that the given schema module exists, it has a corresponding table, and its fields are correct.

  See `assert_schema_fields/2` for details about field assertion.
  """
  def assert_schema(schema_module, field_tuples) when is_list(field_tuples) do
    assert_schema_module_exists(schema_module, field_tuples)
    assert_table_exists(schema_module, field_tuples)
    assert_schema_fields(schema_module, field_tuples)
  end

  def assert_schema_module_exists(schema_module, field_tuples) do
    field_list = fields_for_generator(field_tuples)
    table_name = Schema.table_name(schema_module)

    if not Schema.module_exists?(schema_module) do
      """
      Expected schema module “#{Schema.module_name(schema_module)}” to exist, but it doesn’t.

      A possible remedy is to run this on the command line:

        mix phx.gen.schema --binary-id #{Schema.module_name(schema_module, :drop_prefix)} #{table_name} #{field_list}
      """
      |> flunk()
    end
  end

  defp fields_for_generator(field_tuples) do
    field_tuples
    |> Schema.reject_autogenerated_fields()
    |> colon_separated()
  end

  def assert_table_exists(schema_module, field_tuples) do
    table_name = Schema.table_name(schema_module)

    fields_for_migration =
      field_tuples
      |> Schema.reject_autogenerated_fields()
      |> Enum.map(&"add #{inspect_contents(&1)}")

    if not Schema.table_exists?(schema_module) do
      """
      Expected database table “#{table_name}” to exist, but it doesn’t.

      1. You could create a new migration with this mix task:

         mix ecto.gen.migration create_#{table_name}

      2. Your migration could look like this:

         def change() do
           create table(:#{table_name}) do
      #{fields_for_migration |> indented_list(7)}

             timestamps()
           end
         end
      """
      |> flunk()
    end
  end

  @doc """
  Assert that a schema and its corresponding database table have the correct fields.

  Currently the error message is pretty generic, but there is probably enough information to provide the exact steps
  for fixing any problems.

  ## Example

      assert_schema_fields(Person, [{:id, :id}, {:first_name, :string}, {:age, :integer}])

  Fields are tuples to allow for asserting on extra metadata in the future, like:
  `[{:first_name, :string, :required}, ...]`
  """
  def assert_schema_fields(schema_module, field_tuples) when is_list(field_tuples) do
    table_name = Schema.table_name(schema_module)

    assertion_fields = field_tuples
    database_fields = schema_module |> Schema.table_name() |> Database.fields()
    schema_fields = schema_module |> Schema.fields_with_types()

    all_field_names =
      for field_set <- [assertion_fields, database_fields, schema_fields],
          field <- field_set,
          uniq: true,
          do: field |> elem(0)

    table_rows =
      for field_name <- all_field_names |> Enum.sort() do
        [
          field_name,
          assertion_fields |> field_metadata(field_name),
          database_fields |> field_metadata(field_name),
          schema_fields |> field_metadata(field_name)
        ]
      end

    if table_rows |> List.flatten() |> Enum.any?(&(&1 == nil)) do
      table =
        TableRex.Table.new(table_rows, ["", "ASSERTION", "DATABASE", "SCHEMA"])
        |> TableRex.Table.render!(horizontal_style: :off, vertical_style: :off)

      """
      Mismatch between asserted fields, fields in database, and fields in schema:

      #{table}

      1. To add to or remove from the assertion, edit the test.

      2. To add to or remove from the database:

         a. Create a migration with one of:
            *  mix ecto.gen.migration add_column1_column2_to_#{table_name}
            *  mix ecto.gen.migration remove_column1_column_2_from_#{table_name}

         b. In the newly-generated migration, modify the change function:

            def change() do
              alter table(:#{table_name}) do
                add :column_name, :type # [, options]
                remove :column_name, :type # [, options]
              end
            end

      3. To add to or remove from the schema, edit the “#{inspect(schema_module)}” schema.
      """
      |> flunk()
    end

    for field_name <- all_field_names |> Enum.sort() do
      assertion_type = assertion_fields |> field_metadata(field_name)
      database_type = database_fields |> field_metadata(field_name)
      schema_type = schema_fields |> field_metadata(field_name)

      with {:error, message} <- match_types(assertion_type, database_type, schema_type) do
        flunk("""
        Schema type mismatch for field #{field_name}:

        #{message}

        Assertion type: #{inspect(assertion_type)}
        Database type: #{inspect(database_type)}
        Elixir schema type: #{inspect(schema_type)}
        """)
      end
    end
  end

  defp match_types(:boolean, %{data_type: "boolean"}, :boolean), do: :ok
  defp match_types(:binary_id, %{data_type: "uuid"}, :binary_id), do: :ok
  defp match_types(:string, %{data_type: "text"}, :string), do: :ok
  defp match_types(:string, %{data_type: "USER-DEFINED", udt_name: "citext"}, :string), do: :ok
  defp match_types(:naive_datetime, %{data_type: "timestamp without time zone"}, :naive_datetime), do: :ok
  defp match_types(:naive_datetime, %{data_type: "timestamp without time zone"}, :utc_datetime), do: :ok
  defp match_types(:utc_datetime, %{data_type: "timestamp without time zone"}, :utc_datetime), do: :ok
  defp match_types(:date, %{data_type: "date"}, :date), do: :ok
  defp match_types(:string, %{data_type: "character varying"}, :string), do: {:error, "You should use a text postgres type for string data"}
  defp match_types(:integer, %{data_type: "bigint"}, :integer), do: :ok
  defp match_types(:bigserial, %{data_type: "bigint"}, :integer), do: :ok
  defp match_types({:array, :string}, %{data_type: "ARRAY", element_data_type: "text"}, {:array, :string}), do: :ok
  defp match_types(_assertion_type, _database_type, _schema_type), do: {:error, "These types did not match"}

  defp colon_separated(tuples),
    do:
      tuples
      |> Enum.map(fn
        {k, {v1, v2}} -> "#{k}:#{v1}:#{v2}"
        {k, v} -> "#{k}:#{v}"
      end)
      |> Enum.join(" ")

  defp field_metadata(field_list, field_name) do
    Enum.find_value(field_list, fn field ->
      if elem(field, 0) == field_name,
        do: elem(field, 1),
        else: nil
    end)
  end

  defp indent(string, indent_size),
    do: String.duplicate(" ", indent_size) <> string

  defp indented_list(list, indent_size, trailing_character \\ ""),
    do: list |> Enum.map(&indent(&1, indent_size)) |> Enum.join(trailing_character <> "\n")

  defp inspect_contents(tuple) when is_tuple(tuple) do
    tuple |> Tuple.to_list() |> Enum.map(&inspect/1) |> Enum.join(", ")
  end

  defmodule Database do
    alias Epicenter.Repo

    def fields(table_name) do
      for [name, data_type, udt_name, element_data_type] <- field_query(table_name),
          do: {Euclid.Extra.Atom.from_string(name), %{data_type: data_type, udt_name: udt_name, element_data_type: element_data_type}}
    end

    defp field_query(table_name),
      do:
        query(
          """
          SELECT information_schema.columns.column_name, information_schema.columns.data_type, information_schema.columns.udt_name, information_schema.element_types.data_type
            FROM information_schema.columns
            LEFT JOIN information_schema.element_types
              ON information_schema.columns.dtd_identifier=information_schema.element_types.collection_type_identifier
                AND information_schema.element_types.object_name = $1
                AND information_schema.element_types.object_type = 'TABLE'
            WHERE information_schema.columns.table_name = $1
          """,
          [table_name]
        )

    def table_names(),
      do: "select table_name from information_schema.tables where table_schema = 'public'" |> query() |> List.flatten()

    def has_table?(table_name),
      do: table_name in table_names()

    def query(string, args \\ []),
      do: Repo.query!(string, args).rows
  end

  defmodule Schema do
    def field_type(module, field),
      do: module.__schema__(:type, field)

    def fields(module),
      do: module.__schema__(:fields) |> Enum.sort()

    def fields_with_types(module),
      do: for(field <- fields(module), do: {field, field_type(module, field)})

    def module_exists?(module),
      do: function_exported?(module, :__info__, 1)

    def module_name(module),
      do: inspect(module)

    def module_name(module, :drop_prefix),
      do: module |> module_name() |> String.split(".") |> Enum.reject(&(&1 in ~w{Epicenter EpicenterWeb})) |> Enum.join(".")

    def reject_autogenerated_fields(fields),
      do: fields |> Enum.reject(fn field -> elem(field, 0) in [:id, :inserted_at, :updated_at] end)

    def table_exists?(module),
      do: module |> table_name() |> Database.has_table?()

    def table_name(module),
      do: module |> module_name() |> String.split(".") |> List.last() |> Inflex.underscore() |> Inflex.pluralize()
  end
end
