defmodule EpiViewpoint.Csv do
  alias Explorer.DataFrame
  NimbleCSV.define(EpiViewpoint.Csv.Parser,
    separator: ",",
    escape: "\"",
    line_separator: "\r\n",
    trim_bom: true,
    moduledoc: """
    A CSV parser that uses comma as separator and double-quotes as escape according to RFC4180,
    and trims byte-order marks (BOMs) that may be generated by some systems.
    """
  )

  alias EpiViewpoint.Extra

  def read(string, header_transformer, headers) when is_binary(string),
    do: read(string, header_transformer, headers, &parse_with_explorer/1)

  def read(input, header_transformer, [required: required_headers, optional: optional_headers], parser) do
    with {:ok, df} <- parse(input, parser) do
      provided_headers = df |> DataFrame.names() |> Enum.map(&String.trim/1) |> header_transformer.()
      df = DataFrame.rename(df, provided_headers)

      case required_headers -- provided_headers do
        [] ->
          headers =
            MapSet.intersection(
              MapSet.new(provided_headers),
              MapSet.union(MapSet.new(required_headers), MapSet.new(optional_headers))
            )
            |> MapSet.to_list()

          data =
            df
            |> DataFrame.rename_with(fn col ->
                 col
                 |> String.trim()
               end)
            |> DataFrame.select(headers)
            |> DataFrame.to_rows()
            |> Enum.map(fn row ->
              for header <- headers, into: %{} do
                {header, row[header] |> Extra.String.trim()}
              end
            end)

          {:ok, data}

        missing_headers ->
          {:error, :missing_headers, missing_headers |> Enum.sort()}
      end
    end
  end

  defp parse(input, parser) do
    EpiViewpoint.Csv.Parser.parse_string(input, headers: true)
    {:ok, parser.(input)}
  rescue
    e ->
      hint = "make sure there are no spaces between the field separators (commas) and the quotes around field contents"
      {:invalid_csv, "#{Exception.message(e)} (#{hint})"}
  end

  defp parse_with_explorer(input) do
    # Remove BOM if present
    input = String.trim_leading(input, "\uFEFF")

    DataFrame.load_csv!(input, infer_schema_length: 0)
  end
end
