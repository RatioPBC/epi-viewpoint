defmodule EpiViewpoint.DataFile do
  alias Explorer.DataFrame
  alias EpiViewpoint.Extra

  NimbleCSV.define(EpiViewpoint.DataFile.Parser,
    separator: ",",
    escape: "\"",
    line_separator: "\r\n",
    trim_bom: true,
    moduledoc: """
    A CSV parser that uses comma as separator and double-quotes as escape according to RFC4180,
    and trims byte-order marks (BOMs) that may be generated by some systems.
    """
  )

  def read(string, :csv, header_transformer, headers) when is_binary(string) do
    read(string, header_transformer, headers, &parse_csv/1)
  end

  def read(string, :ndjson, header_transformer, headers) when is_binary(string) do
    read(string, header_transformer, headers, &parse_ndjson/1)
  end

  def read(input, header_transformer, [required: required_headers, optional: optional_headers], parser) do
    with {:ok, df} <- parser.(input),
         provided_headers <- df |> DataFrame.names() |> Enum.map(&String.trim/1) |> header_transformer.(),
         :ok <- validate_headers(provided_headers, required_headers) do
      headers = get_valid_headers(provided_headers, required_headers, optional_headers)

      data =
        df
        |> DataFrame.rename(provided_headers)
        |> DataFrame.rename_with(&String.trim/1)
        |> DataFrame.select(headers)
        |> DataFrame.to_rows()
        |> Enum.map(&process_row(&1, headers))

      {:ok, data}
    end
  end

  defp validate_headers(provided_headers, required_headers) do
    case required_headers -- provided_headers do
      [] -> :ok
      missing_headers -> {:error, :missing_headers, Enum.sort(missing_headers)}
    end
  end

  defp get_valid_headers(provided_headers, required_headers, optional_headers) do
    MapSet.intersection(
      MapSet.new(provided_headers),
      MapSet.union(MapSet.new(required_headers), MapSet.new(optional_headers))
    )
    |> MapSet.to_list()
  end

  defp process_row(row, headers) do
    for header <- headers, into: %{} do
      {header, row[header] |> Extra.String.trim()}
    end
  end

  defp parse_csv(input) do

    input
    |> validate_csv()
    |> remove_bom()
    |> DataFrame.load_csv(infer_schema_length: 0)
  rescue
    e ->
      hint = "make sure there are no spaces between the field separators (commas) and the quotes around field contents"
      {:invalid_csv, "#{Exception.message(e)} (#{hint})"}
  end

  defp parse_ndjson(input) do
    DataFrame.load_ndjson(input)
  end

  defp validate_csv(input) do
    EpiViewpoint.DataFile.Parser.parse_string(input, headers: true)
    input
  end

  defp remove_bom(input) do
    String.trim_leading(input, "\uFEFF")
  end
end
